#!/bin/bash

# VPN Automation Setup Script
# Sets up automatic Tailscale exit node management based on WiFi BSSID trust level
# Compatible with Ansible automation for new machine setup

set -euo pipefail

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
VPN_AUTO_DIR="$HOME/.config/vpn-auto"
SYSTEMD_USER_DIR="$HOME/.config/systemd/user"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check dependencies
check_dependencies() {
    log_info "Checking dependencies..."
    
    local missing_deps=()
    
    # Check required commands
    for cmd in tailscale jq iwconfig systemctl nmcli; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps+=("$cmd")
        fi
    done
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        log_error "Please install them before running this script"
        exit 1
    fi
    
    # Check if Tailscale is running
    if ! tailscale status >/dev/null 2>&1; then
        log_error "Tailscale is not running or not configured"
        log_error "Please setup Tailscale first: sudo tailscale up"
        exit 1
    fi
    
    log_info "All dependencies satisfied"
}

# Create directories
create_directories() {
    log_info "Creating configuration directories..."
    mkdir -p "$VPN_AUTO_DIR"
    mkdir -p "$SYSTEMD_USER_DIR"
}

# Extract Haunter network BSSIDs
extract_haunter_bssids() {
    log_info "Extracting Haunter network BSSIDs..."
    
    local bssid_file="$VPN_AUTO_DIR/trusted-bssids.conf"
    
    # Create header
    cat > "$bssid_file" << 'EOF'
# Trusted WiFi BSSIDs (Haunter networks)
# Format: BSSID (one per line)
# Lines starting with # are comments
# Auto-generated by setup script

EOF

    # Extract BSSIDs from saved connections
    local found_networks=0
    while IFS= read -r line; do
        if [[ -z "$line" ]]; then continue; fi
        
        local conn_name=$(echo "$line" | sed 's/  *[a-f0-9-]*  *wifi.*$//')
        
        log_info "Processing: $conn_name"
        echo "# $conn_name" >> "$bssid_file"
        
        local bssids
        if bssids=$(nmcli connection show "$conn_name" 2>/dev/null | grep '802-11-wireless.seen-bssids:' | cut -d: -f2- | xargs | tr ',' '\n'); then
            if [[ -n "$bssids" && "$bssids" != "--" ]]; then
                echo "$bssids" >> "$bssid_file"
                found_networks=$((found_networks + 1))
            else
                echo "# No BSSIDs recorded for this network" >> "$bssid_file"
            fi
        else
            echo "# Could not retrieve BSSIDs for this network" >> "$bssid_file"
        fi
        echo "" >> "$bssid_file"
        
    done < <(nmcli connection show | grep -i haunter)
    
    if [[ $found_networks -eq 0 ]]; then
        log_warn "No Haunter networks with BSSIDs found"
        log_warn "The automation will not work until you connect to trusted networks"
    else
        log_info "Found $found_networks Haunter networks with BSSIDs"
    fi
}

# Create WiFi monitoring script
create_monitoring_script() {
    log_info "Creating WiFi monitoring script..."
    
    cat > "$VPN_AUTO_DIR/wifi-monitor.sh" << 'EOF'
#!/bin/bash

# VPN Auto Manager - WiFi Monitor
# Automatically manages Tailscale exit node based on WiFi BSSID trust level

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
CONFIG_FILE="$SCRIPT_DIR/trusted-bssids.conf"
LOG_FILE="$SCRIPT_DIR/wifi-monitor.log"
STATE_FILE="$SCRIPT_DIR/current-state"

# Configuration
INTERFACE="wlp0s20f3"  # Primary WiFi interface
CHECK_INTERVAL=5       # Seconds between checks
EXIT_NODE="exitserver" # Tailscale exit node name

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Load trusted BSSIDs from config file
load_trusted_bssids() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log "ERROR: Config file not found: $CONFIG_FILE"
        exit 1
    fi
    
    # Read non-comment, non-empty lines
    trusted_bssids=($(grep -v '^#' "$CONFIG_FILE" | grep -v '^[[:space:]]*$'))
    log "Loaded ${#trusted_bssids[@]} trusted BSSIDs"
}

# Get current WiFi BSSID
get_current_bssid() {
    iwconfig "$INTERFACE" 2>/dev/null | grep -o 'Access Point: [A-F0-9:]*' | cut -d' ' -f3
}

# Check if current BSSID is trusted
is_trusted_network() {
    local current_bssid="$1"
    
    if [[ -z "$current_bssid" || "$current_bssid" == "Not-Associated" ]]; then
        return 1  # Not connected or no BSSID
    fi
    
    for trusted in "${trusted_bssids[@]}"; do
        if [[ "$current_bssid" == "$trusted" ]]; then
            return 0  # Trusted
        fi
    done
    return 1  # Not trusted
}

# Get current Tailscale exit node status
get_exit_node_status() {
    if tailscale status --peers --json | jq -e '.ExitNodeStatus.ID != null' >/dev/null 2>&1; then
        echo "ON"
    else
        echo "OFF"
    fi
}

# Enable exit node
enable_exit_node() {
    log "Enabling exit node: $EXIT_NODE"
    if sudo tailscale set --exit-node="$EXIT_NODE" --exit-node-allow-lan-access=true; then
        log "Exit node enabled successfully"
        return 0
    else
        log "ERROR: Failed to enable exit node"
        return 1
    fi
}

# Disable exit node  
disable_exit_node() {
    log "Disabling exit node"
    if sudo tailscale set --exit-node=; then
        log "Exit node disabled successfully"
        return 0
    else
        log "ERROR: Failed to disable exit node"
        return 1
    fi
}

# Read previous state
read_previous_state() {
    if [[ -f "$STATE_FILE" ]]; then
        cat "$STATE_FILE"
    else
        echo "UNKNOWN"
    fi
}

# Write current state
write_current_state() {
    echo "$1" > "$STATE_FILE"
}

# Main monitoring loop
monitor_wifi() {
    log "Starting WiFi monitor (PID: $$)"
    log "Interface: $INTERFACE, Check interval: ${CHECK_INTERVAL}s"
    
    load_trusted_bssids
    
    while true; do
        current_bssid=$(get_current_bssid)
        exit_node_status=$(get_exit_node_status)
        previous_state=$(read_previous_state)
        
        if is_trusted_network "$current_bssid"; then
            network_status="TRUSTED"
            desired_exit_node="OFF"
        else
            network_status="UNTRUSTED"
            desired_exit_node="ON"
        fi
        
        current_state="${network_status}:${exit_node_status}"
        
        # Only act if state changed or exit node status doesn't match desired
        if [[ "$current_state" != "$previous_state" || "$exit_node_status" != "$desired_exit_node" ]]; then
            log "State change detected:"
            log "  Previous: $previous_state"
            log "  Current:  $current_state"
            log "  BSSID:    $current_bssid"
            log "  Network:  $network_status"
            log "  Exit node desired: $desired_exit_node"
            
            case "$network_status" in
                "TRUSTED")
                    if [[ "$exit_node_status" == "ON" ]]; then
                        disable_exit_node
                    fi
                    ;;
                "UNTRUSTED")
                    if [[ "$exit_node_status" == "OFF" ]]; then
                        enable_exit_node
                    fi
                    ;;
            esac
            
            write_current_state "$current_state"
        fi
        
        sleep "$CHECK_INTERVAL"
    done
}

# Handle script termination
cleanup() {
    log "WiFi monitor stopping (PID: $$)"
    exit 0
}

trap cleanup SIGTERM SIGINT

# Start monitoring
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    monitor_wifi
fi
EOF

    chmod +x "$VPN_AUTO_DIR/wifi-monitor.sh"
}

# Create systemd service
create_systemd_service() {
    log_info "Creating systemd user service..."
    
    cat > "$SYSTEMD_USER_DIR/vpn-auto.service" << 'EOF'
[Unit]
Description=VPN Auto Manager - WiFi Monitor
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=%h/.config/vpn-auto/wifi-monitor.sh
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

# Environment
Environment=PATH=/usr/bin:/bin:/usr/sbin:/sbin

# Security settings
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=%h/.config/vpn-auto

[Install]
WantedBy=default.target
EOF
}

# Configure polybar module (only if in dotfiles directory)
configure_polybar() {
    local polybar_config="$SCRIPT_DIR/.config/polybar/config.ini"
    
    if [[ ! -f "$polybar_config" ]]; then
        log_warn "Polybar config not found at: $polybar_config"
        log_warn "Please manually update your polybar configuration"
        return
    fi
    
    log_info "Updating polybar VPN module..."
    
    # Check if the module already has the correct configuration
    if grep -q 'EXN.*%{F#' "$polybar_config"; then
        log_info "Polybar VPN module already configured"
        return
    fi
    
    # Backup original config
    cp "$polybar_config" "$polybar_config.bak"
    
    # Update the VPN module
    sed -i '/^\[module\/vpn\]/,/^$/c\
[module/vpn]\
type = custom/script\
exec = if tailscale status --peers --json | jq -e '\''.ExitNodeStatus.ID != null'\'' >/dev/null 2>&1; then echo "%{F#cba6f7}EXN%{F-} %{F#a6e3a1}On%{F-}"; else echo "%{F#cba6f7}EXN%{F-} %{F#f38ba8}Off%{F-}"; fi\
interval = 2\
format-prefix-foreground = ${colors.primary}\
format-prefix = ""\
label = %output%\
format-fail = "Error"\
' "$polybar_config"
    
    log_info "Polybar configuration updated (backup saved as config.ini.bak)"
}

# Enable and start service
enable_service() {
    log_info "Enabling and starting VPN automation service..."
    
    systemctl --user daemon-reload
    systemctl --user enable vpn-auto.service
    
    if systemctl --user is-active --quiet vpn-auto.service; then
        log_info "Restarting existing service..."
        systemctl --user restart vpn-auto.service
    else
        log_info "Starting service..."
        systemctl --user start vpn-auto.service
    fi
    
    sleep 2
    
    if systemctl --user is-active --quiet vpn-auto.service; then
        log_info "VPN automation service is running"
    else
        log_error "Failed to start VPN automation service"
        log_info "Check status with: systemctl --user status vpn-auto.service"
        exit 1
    fi
}

# Show status and instructions
show_status() {
    log_info "Setup completed successfully!"
    echo
    log_info "Configuration files created:"
    echo "  • $VPN_AUTO_DIR/trusted-bssids.conf"
    echo "  • $VPN_AUTO_DIR/wifi-monitor.sh"
    echo "  • $SYSTEMD_USER_DIR/vpn-auto.service"
    echo
    log_info "Service status:"
    systemctl --user status vpn-auto.service --no-pager -l
    echo
    log_info "Useful commands:"
    echo "  • Check logs: journalctl --user -u vpn-auto.service -f"
    echo "  • Monitor activity: tail -f $VPN_AUTO_DIR/wifi-monitor.log"
    echo "  • Stop service: systemctl --user stop vpn-auto.service"
    echo "  • Start service: systemctl --user start vpn-auto.service"
    echo
    log_info "To add new trusted BSSIDs, edit: $VPN_AUTO_DIR/trusted-bssids.conf"
    log_info "Then restart: systemctl --user restart vpn-auto.service"
}

# Main execution
main() {
    log_info "Setting up VPN automation system..."
    
    check_dependencies
    create_directories
    extract_haunter_bssids
    create_monitoring_script
    create_systemd_service
    configure_polybar
    enable_service
    show_status
}

# Run setup if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi